{
  "JoinPatternDetector": {
    "description": "Optimization by denormalizing frequently joined tables into a single fact table.",
    "solution_template": {
      "ddl": [
        {
          "statement": "CREATE SCHEMA IF NOT EXISTS {catalog}.optimized;"
        },
        {
          "statement": "CREATE TABLE {catalog}.optimized.fact_denormalized_data (\n  -- Columns from the base table\n  col_a INT,\n  col_b VARCHAR,\n  -- Columns from the joined table\n  col_c DECIMAL,\n  col_d DATE\n) WITH (\n  format = 'PARQUET',\n  partitioning = ARRAY['day(col_d)']\n);"
        }
      ],
      "migrations": [
        {
          "statement": "INSERT INTO {catalog}.optimized.fact_denormalized_data\nSELECT\n  t1.col_a,\n  t1.col_b,\n  t2.col_c,\n  t2.col_d\nFROM {catalog}.{schema}.table1 AS t1\nJOIN {catalog}.{schema}.table2 AS t2 ON t1.key = t2.key;"
        }
      ],
      "queries": [
        {
          "queryid": "{highest_cost_query_id}",
          "query": "SELECT\n  col_a,\n  col_c\nFROM {catalog}.optimized.fact_denormalized_data\nWHERE day(col_d) = '2025-01-01';"
        }
      ]
    }
  },
  "PartitioningCandidateDetector": {
    "description": "Optimization of a large table by adding partitioning on frequently filtered columns.",
    "solution_template": {
      "ddl": [
        {
          "statement": "CREATE SCHEMA IF NOT EXISTS {catalog}.optimized;"
        },
        {
          "statement": "CREATE TABLE {catalog}.optimized.partitioned_table (\n  -- All columns from the original table\n  event_date DATE,\n  user_id INT,\n  event_type VARCHAR\n) WITH (\n  format = 'PARQUET',\n  partitioning = ARRAY['event_date', 'event_type']\n);"
        }
      ],
      "migrations": [
        {
          "statement": "INSERT INTO {catalog}.optimized.partitioned_table\nSELECT * FROM {catalog}.{schema}.original_table;"
        }
      ],
      "queries": [
        {
          "queryid": "{highest_cost_query_id}",
          "query": "SELECT user_id, count(*)\nFROM {catalog}.optimized.partitioned_table\nWHERE event_date = '2025-01-01' AND event_type = 'login';"
        }
      ]
    }
  },
  "CrossJoinDetector": {
    "description": "Fixing an inefficient CROSS JOIN by adding a join condition.",
    "solution_template": {
      "ddl": [],
      "migrations": [],
      "queries": [
        {
          "queryid": "{highest_cost_query_id}",
          "query": "-- The original query had a CROSS JOIN. Here is the corrected version with an INNER JOIN:\nSELECT u.name, c.city_name\nFROM {catalog}.{schema}.users AS u\nJOIN {catalog}.{schema}.cities AS c ON u.city_id = c.id;"
        }
      ]
    }
  },
  "InefficientAggregationDetector": {
    "description": "Moving non-aggregate conditions from HAVING to WHERE for better performance.",
    "solution_template": {
      "ddl": [],
      "migrations": [],
      "queries": [
        {
          "queryid": "{highest_cost_query_id}",
          "query": "-- The condition `city_id = 1` was moved from HAVING to WHERE for pre-filtering.\nSELECT city_id, COUNT(*)\nFROM {catalog}.{schema}.users\nWHERE city_id = 1\nGROUP BY city_id\nHAVING COUNT(*) > 10;"
        }
      ]
    }
  },
  "SelectStarDetector": {
    "description": "Replacing `SELECT *` with an explicit list of required columns.",
    "solution_template": {
      "ddl": [],
      "migrations": [],
      "queries": [
        {
          "queryid": "{highest_cost_query_id}",
          "query": "-- The query was rewritten to avoid `SELECT *` and read only the necessary columns.\nSELECT\n  col_1,\n  col_5,\n  col_23\nFROM {catalog}.{schema}.wide_table;"
        }
      ]
    }
  }
}